--Aufgabe 1a
CREATE FUNCTION DATE_DIFF_DAYS(START DATE, END DATE) 
RETURNS INTEGER 
DETERMINISTIC 
CONTAINS SQL 
RETURN DAYS(START) - DAYS(END);

CREATE FUNCTION DATE_DIFF_WEEKS(START DATE, END DATE)
RETURNS INTEGER
DETERMINISTIC 
CONTAINS SQL
RETURN (DAYS(START) - DAYS(END)) / 7;


--Aufgabe 1b
CREATE OR REPLACE FUNCTION "PROJECTS_OF"(DEPTNR CHAR(3))
RETURNS TABLE(projname VARCHAR(20), dauer VARCHAR(20))
DETERMINISTIC READS SQL DATA
RETURN 
	SELECT 
		p.projname, 
		CAST(DATE_DIFF_WEEKS(p.prstdate, p.prendate) AS VARCHAR(10)) ||
		' Wochen und ' ||
		CAST(MOD(DATE_DIFF_DAYS(p.prstdate, p.prendate), 7) AS VARCHAR(10)) ||
		' Tage'		
	FROM department d 
	INNER JOIN project p 
	ON d.deptno = p.deptno 
	WHERE d.deptno = deptnr;


--Aufgabe 1c
CREATE OR REPLACE FUNCTION "NEXT_JUBILEE"()
RETURNS TABLE(firstname VARCHAR(20), lastname VARCHAR(20), zeit_in_tagen INTEGER)
DETERMINISTIC READS SQL DATA
RETURN
	SELECT 
		firstnme, lastname,
		DATE_DIFF_DAYS(CURRENT DATE, DATE(hiredate + 10 YEARS))
	FROM employee
	WHERE
		DATE_DIFF_DAYS(CURRENT DATE, DATE(hiredate + 10 YEARS))
		=
		(
			SELECT 
				MIN(DATE_DIFF_DAYS(CURRENT DATE, DATE(hiredate + 10 YEARS)))
			FROM employee
			WHERE 
				DATE_DIFF_DAYS(CURRENT DATE, DATE(hiredate + 10 YEARS)) > 0
		);

--Aufgabe 2.1
CREATE FUNCTION FORMAT_DOUBLE(VALUE DOUBLE, NODIGITS INT) 
RETURNS VARCHAR(64) 
BEGIN 
	DECLARE TEMPVALUE BIGINT; 
	DECLARE RESULT VARCHAR(64);
	SET TEMPVALUE = POWER(10, NODIGITS);  
	SET RESULT = RTRIM(CAST(TEMPVALUE AS CHAR(64))); 
	IF NODIGITS = 0 THEN RETURN RESULT;
	END IF; 
	SET TEMPVALUE = CAST((VALUE * TEMPVALUE) AS BIGINT);
	SET RESULT = CAST(TEMPVALUE AS VARCHAR(64));
	SET RESULT = SUBSTR(RESULT, 1, length(RESULT) - NODIGITS) || '.' || SUBSTR(RESULT, length(RESULT) - NODIGITS +1);
	RETURN RESULT;
END 

	
--Aufgabe 2.2
CREATE FUNCTION LUC(I INTEGER)
RETURNS BIGINT 
BEGIN
	DECLARE N INTEGER DEFAULT 2;
	DECLARE X INTEGER DEFAULT 2;
	DECLARE Y INTEGER DEFAULT 1;
	DECLARE Z INTEGER DEFAULT 0;
	IF I = 0 THEN RETURN 2;
	ELSEIF I = 1 THEN RETURN 1;
	END IF;
	WHILE N < I DO
		SET Z = Y;
		SET Y = X + Y;
		SET X = Z;
		SET N = N + 1;
	END WHILE;
	RETURN Y;
END


--Aufgabe 3.1
CREATE OR REPLACE PROCEDURE "RENAME_OBJECT"(IN OLDNAME VARCHAR(32), IN NEWNAME VARCHAR(32))
BEGIN
	DECLARE TABLECOUNT_OLDNAME INTEGER;
	DECLARE TABLECOUNT_NEWNAME INTEGER;
	DECLARE MESSAGE_1 VARCHAR(256); 
	DECLARE MESSAGE_2 VARCHAR(256);
	SELECT count(*)
	INTO TABLECOUNT_OLDNAME
	FROM syscat.tables
	WHERE type = 'T' AND tabname = OLDNAME;
	SELECT count(*)
	INTO TABLECOUNT_NEWNAME
	FROM syscat.tables
	WHERE type = 'T' AND tabname = NEWNAME;	
	IF TABLECOUNT_OLDNAME = 0 THEN
		SET MESSAGE_1 = 'Es existiert keine Tabelle mit dem Namen ' || OLDNAME;
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = MESSAGE_1;
	END IF;
	IF TABLECOUNT_NEWNAME = 1 THEN
		SET MESSAGE_2 = 'Eine Tabelle mit dem Namen ' || NEWNAME || ' existiert bereits.';
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = MESSAGE_2;
	END IF;
	call SYSPROC.ADMIN_MOVE_TABLE ('db2ins28', OLDNAME, NEWNAME, '', 'MOVE');
END @


--Aufgabe 3.2


--Aufgabe 4.1
--(C) A sourced UDF


--Aufgabe 4.2
--(B) Improves application concurrency


--Aufgabe 4.3
--(C) sourced user-defined function


--Aufgabe 4.4
--(B) Ability to return user-defined messages


--Aufgabe 4.5
--(A) An SQL stored procedure that accepts an integer value as 
--	  input and returns a cursor for all rows found in table TAB1 to 
-- 	  procedure caller

--Aufgabe 4.6

--(B) DROP SPECIFIC PROCEDURE SProc